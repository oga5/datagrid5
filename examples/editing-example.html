<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataGrid5 - Cell Editing Example</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .header {
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 28px;
            color: #2d3748;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #718096;
            font-size: 14px;
        }

        .controls {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            border-top: 1px solid #e2e8f0;
        }

        button {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover {
            background: #5a67d8;
        }

        button:active {
            transform: translateY(1px);
        }

        .btn-secondary {
            background: #48bb78;
        }

        .btn-secondary:hover {
            background: #38a169;
        }

        .btn-danger {
            background: #f56565;
        }

        .btn-danger:hover {
            background: #e53e3e;
        }

        .info-section {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.85);
            border-top: 1px solid #e2e8f0;
        }

        .info-title {
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .info-list {
            list-style: none;
            font-size: 13px;
            color: #4a5568;
            line-height: 1.6;
        }

        .info-list li {
            padding: 3px 0;
        }

        .info-list strong {
            color: #667eea;
        }

        .grid-container {
            flex: 1;
            position: relative;
            min-height: 0;
            background: white;
            margin: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            overflow: hidden;
        }

        #scroll-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
            z-index: 3;
        }

        #scroll-content {
            position: relative;
            pointer-events: none;
        }

        #webgl-canvas, #text-canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            pointer-events: none;
        }

        #webgl-canvas {
            z-index: 1;
        }

        #text-canvas {
            z-index: 2;
            pointer-events: all;
        }

        #text-canvas {
            cursor: cell;
        }

        #cell-editor {
            position: absolute;
            border: 2px solid #667eea;
            outline: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            padding: 4px;
            box-sizing: border-box;
            z-index: 1000;
            background: white;
        }

        .status-bar {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 20px;
            font-size: 13px;
            color: #4a5568;
        }

        .status-item {
            display: flex;
            gap: 5px;
        }

        .status-label {
            font-weight: bold;
            color: #2d3748;
        }

        .edit-history {
            max-height: 100px;
            overflow-y: auto;
            padding: 8px;
            background: #f7fafc;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 5px;
        }

        .edit-entry {
            padding: 2px 0;
            color: #4a5568;
        }

        .controls label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            color: #2d3748;
        }

        .controls input[type="checkbox"] {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>DataGrid5 - ã‚»ãƒ«ç·¨é›†æ©Ÿèƒ½ãƒ‡ãƒ¢</h1>
        <p class="subtitle">Cell Editing Example - Double-click cells to edit</p>
    </div>

    <div class="controls">
        <button id="load-sample-btn" class="btn-secondary">ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿èª­è¾¼</button>
        <button id="undo-btn">å…ƒã«æˆ»ã™ (Undo)</button>
        <button id="redo-btn">ã‚„ã‚Šç›´ã— (Redo)</button>
        <button id="clear-btn" class="btn-danger">å…¨ã‚¯ãƒªã‚¢</button>
        <label>
            <input type="checkbox" id="readonly-mode" />
            èª­å–å°‚ç”¨ãƒ¢ãƒ¼ãƒ‰
        </label>
    </div>

    <div class="info-section">
        <div class="info-title">ğŸ“ ç·¨é›†æ“ä½œ / Editing Operations:</div>
        <ul class="info-list">
            <li><strong>ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯:</strong> ã‚»ãƒ«ã‚’ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã«ã™ã‚‹</li>
            <li><strong>Enter:</strong> ç·¨é›†ã‚’ç¢ºå®šã—ã¦æ¬¡ã®è¡Œã¸</li>
            <li><strong>Tab:</strong> ç·¨é›†ã‚’ç¢ºå®šã—ã¦æ¬¡ã®åˆ—ã¸</li>
            <li><strong>Escape:</strong> ç·¨é›†ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«</li>
            <li><strong>Ctrl+Z / Cmd+Z:</strong> å…ƒã«æˆ»ã™</li>
            <li><strong>Ctrl+Y / Cmd+Y:</strong> ã‚„ã‚Šç›´ã—</li>
        </ul>
        <div class="edit-history" id="edit-history">
            <div style="color: #a0aec0;">ç·¨é›†å±¥æ­´ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...</div>
        </div>
    </div>

    <div class="grid-container">
        <canvas id="webgl-canvas"></canvas>
        <canvas id="text-canvas" tabindex="0"></canvas>
        <div id="scroll-container">
            <div id="scroll-content"></div>
        </div>
        <input type="text" id="cell-editor" style="display: none;" />
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span class="status-label">é¸æŠ:</span>
            <span id="selected-cell">-</span>
        </div>
        <div class="status-item">
            <span class="status-label">ç·¨é›†å›æ•°:</span>
            <span id="edit-count">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">çŠ¶æ…‹:</span>
            <span id="edit-status">å¾…æ©Ÿä¸­</span>
        </div>
    </div>

    <script type="module">
        import init, { DataGrid } from '../pkg/datagrid5.js';

        let grid = null;
        let editingRow = null;
        let editingCol = null;
        let editCount = 0;
        let editHistory = [];
        let isInternalScroll = false;

        async function initGrid() {
            await init();

            const webglCanvas = document.getElementById('webgl-canvas');
            const textCanvas = document.getElementById('text-canvas');
            const scrollContainer = document.getElementById('scroll-container');

            // Get container size
            const containerRect = scrollContainer.getBoundingClientRect();
            const width = Math.floor(containerRect.width);
            const height = Math.floor(containerRect.height);

            // Setup canvases
            webglCanvas.width = width;
            webglCanvas.height = height;
            textCanvas.width = width;
            textCanvas.height = height;

            // Create grid (20 rows x 10 columns for editing demo)
            grid = new DataGrid('webgl-canvas', 'text-canvas', 20, 10);

            // Setup event handlers
            setupEventHandlers();
            setupVirtualScroll();

            // Start render loop
            renderLoop();

            console.log('Grid initialized for editing demo');
        }

        function renderLoop() {
            if (!grid) return;
            grid.render();
            requestAnimationFrame(renderLoop);
        }

        function setupEventHandlers() {
            const textCanvas = document.getElementById('text-canvas');

            // Mouse events
            textCanvas.addEventListener('mousedown', (e) => {
                const rect = textCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const modifiers = {
                    shift: e.shiftKey,
                    ctrl: e.ctrlKey || e.metaKey,
                    alt: e.altKey
                };

                grid.handle_mouse_down_with_modifiers(x, y, modifiers);
                updateStatusBar();
            });

            textCanvas.addEventListener('mousemove', (e) => {
                const rect = textCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                grid.handle_mouse_move(x, y);
            });

            textCanvas.addEventListener('mouseup', (e) => {
                const rect = textCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                grid.handle_mouse_up(x, y);
            });

            // Double-click to edit
            textCanvas.addEventListener('dblclick', (e) => {
                const rect = textCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const cellInfo = grid.handle_double_click(x, y);
                if (cellInfo) {
                    const [row, col] = JSON.parse(cellInfo);
                    startCellEdit(row, col);
                }
            });

            // Keyboard events
            textCanvas.addEventListener('keydown', (e) => {
                const modifiers = {
                    shift: e.shiftKey,
                    ctrl: e.ctrlKey || e.metaKey,
                    alt: e.altKey
                };

                // Undo/Redo
                if (modifiers.ctrl) {
                    if (e.key === 'z' || e.key === 'Z') {
                        e.preventDefault();
                        handleUndo();
                        return;
                    }
                    if (e.key === 'y' || e.key === 'Y') {
                        e.preventDefault();
                        handleRedo();
                        return;
                    }
                }

                const handled = grid.handle_keyboard_with_modifiers(e.key, modifiers);
                if (handled) {
                    e.preventDefault();
                    syncScrollPosition();
                    updateStatusBar();
                }
            });

            // Wheel events
            textCanvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                grid.handle_wheel(e.deltaX, e.deltaY);
            });
        }

        function setupVirtualScroll() {
            const scrollContainer = document.getElementById('scroll-container');

            updateVirtualScrollSize();

            scrollContainer.addEventListener('scroll', () => {
                if (!grid || isInternalScroll) {
                    isInternalScroll = false;
                    return;
                }

                const scrollX = scrollContainer.scrollLeft;
                const scrollY = scrollContainer.scrollTop;
                grid.set_scroll(scrollX, scrollY);
            });
        }

        function updateVirtualScrollSize() {
            if (!grid) return;

            const scrollContent = document.getElementById('scroll-content');
            const totalSize = JSON.parse(grid.get_total_size());
            const [totalWidth, totalHeight] = totalSize;

            scrollContent.style.width = totalWidth + 'px';
            scrollContent.style.height = totalHeight + 'px';
        }

        function syncScrollPosition() {
            if (!grid) return;

            const scrollContainer = document.getElementById('scroll-container');
            const viewport = JSON.parse(grid.get_viewport_info_array());
            const [canvasWidth, canvasHeight, scrollY, scrollX] = viewport;

            isInternalScroll = true;
            scrollContainer.scrollLeft = scrollX;
            scrollContainer.scrollTop = scrollY;
        }

        function startCellEdit(row, col) {
            if (!grid) return;

            // Check readonly mode
            const readonlyMode = document.getElementById('readonly-mode').checked;
            if (readonlyMode) {
                updateEditStatus('èª­å–å°‚ç”¨ãƒ¢ãƒ¼ãƒ‰ã§ã™');
                return;
            }

            const editor = document.getElementById('cell-editor');
            const scrollContainer = document.getElementById('scroll-container');
            const gridContainer = document.querySelector('.grid-container');

            // Start edit in grid
            const canEdit = grid.start_edit(row, col);
            if (!canEdit) {
                updateEditStatus('ã“ã®ã‚»ãƒ«ã¯ç·¨é›†ã§ãã¾ã›ã‚“');
                return;
            }

            // Get cell position
            const rect = grid.get_cell_edit_rect(row, col);
            const [x, y, width, height] = rect;

            // Get current value
            const currentValue = grid.get_cell_value(row, col);

            // Calculate position
            const scrollContainerRect = scrollContainer.getBoundingClientRect();
            const gridContainerRect = gridContainer.getBoundingClientRect();
            const offsetX = scrollContainerRect.left - gridContainerRect.left;
            const offsetY = scrollContainerRect.top - gridContainerRect.top;

            // Position editor
            editor.style.left = `${x + offsetX - scrollContainer.scrollLeft}px`;
            editor.style.top = `${y + offsetY - scrollContainer.scrollTop}px`;
            editor.style.width = `${width}px`;
            editor.style.height = `${height}px`;
            editor.style.display = 'block';
            editor.value = currentValue;

            editingRow = row;
            editingCol = col;

            editor.focus();
            editor.select();

            setupEditorEvents(editor, row, col);
            updateEditStatus('ç·¨é›†ä¸­...');
        }

        function endCellEdit(save = false, moveDown = false, moveRight = false) {
            if (!grid || editingRow === null || editingCol === null) return;

            const editor = document.getElementById('cell-editor');
            const oldValue = grid.get_cell_value(editingRow, editingCol);

            if (save && editor.value !== oldValue) {
                // Save value
                grid.update_cell_value(editingRow, editingCol, editor.value);

                // Record edit
                editCount++;
                addEditHistory(editingRow, editingCol, oldValue, editor.value);
                document.getElementById('edit-count').textContent = editCount;
                updateEditStatus('ä¿å­˜ã—ã¾ã—ãŸ');
            } else {
                updateEditStatus('ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ');
            }

            // Hide editor
            editor.style.display = 'none';
            editor.value = '';

            // End edit mode
            grid.end_edit();

            const currentRow = editingRow;
            const currentCol = editingCol;

            editingRow = null;
            editingCol = null;

            // Move to next cell if requested
            if (save && moveDown && currentRow < 19) {
                setTimeout(() => startCellEdit(currentRow + 1, currentCol), 10);
            } else if (save && moveRight && currentCol < 9) {
                setTimeout(() => startCellEdit(currentRow, currentCol + 1), 10);
            } else {
                document.getElementById('text-canvas').focus();
            }
        }

        function setupEditorEvents(editor, row, col) {
            const newEditor = editor.cloneNode(true);
            editor.parentNode.replaceChild(newEditor, editor);

            // Enter to save and move down
            newEditor.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    endCellEdit(true, true, false);
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    endCellEdit(true, false, true);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    endCellEdit(false);
                }
            });

            // Click outside to save
            newEditor.addEventListener('blur', (e) => {
                setTimeout(() => endCellEdit(true), 100);
            });
        }

        function addEditHistory(row, col, oldValue, newValue) {
            const timestamp = new Date().toLocaleTimeString('ja-JP');
            const entry = `[${timestamp}] ã‚»ãƒ«(${row}, ${col}): "${oldValue}" â†’ "${newValue}"`;

            editHistory.unshift(entry);
            if (editHistory.length > 20) {
                editHistory.pop();
            }

            updateEditHistoryDisplay();
        }

        function updateEditHistoryDisplay() {
            const historyDiv = document.getElementById('edit-history');
            if (editHistory.length === 0) {
                historyDiv.innerHTML = '<div style="color: #a0aec0;">ç·¨é›†å±¥æ­´ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...</div>';
            } else {
                historyDiv.innerHTML = editHistory
                    .map(entry => `<div class="edit-entry">${entry}</div>`)
                    .join('');
            }
        }

        function updateStatusBar() {
            if (!grid) return;

            const selectedCell = grid.get_selected_cell();
            if (selectedCell) {
                const [row, col] = JSON.parse(selectedCell);
                const value = grid.get_cell_value(row, col);
                document.getElementById('selected-cell').textContent =
                    `è¡Œ${row}, åˆ—${col} = "${value}"`;
            } else {
                document.getElementById('selected-cell').textContent = '-';
            }
        }

        function updateEditStatus(message) {
            document.getElementById('edit-status').textContent = message;
            setTimeout(() => {
                if (document.getElementById('edit-status').textContent === message) {
                    document.getElementById('edit-status').textContent = 'å¾…æ©Ÿä¸­';
                }
            }, 3000);
        }

        function handleUndo() {
            if (grid) {
                grid.undo();
                updateEditStatus('å…ƒã«æˆ»ã—ã¾ã—ãŸ');
            }
        }

        function handleRedo() {
            if (grid) {
                grid.redo();
                updateEditStatus('ã‚„ã‚Šç›´ã—ã¾ã—ãŸ');
            }
        }

        // Button event handlers
        document.getElementById('load-sample-btn').addEventListener('click', () => {
            if (!grid) return;

            // Set column headers
            const columnHeaders = [
                "å•†å“ID", "å•†å“å", "ä¾¡æ ¼", "åœ¨åº«æ•°", "ã‚«ãƒ†ã‚´ãƒª",
                "ãƒ¡ãƒ¼ã‚«ãƒ¼", "ç™ºå£²æ—¥", "è©•ä¾¡", "è²©å£²æ•°", "å‚™è€ƒ"
            ];

            for (let col = 0; col < columnHeaders.length; col++) {
                grid.update_cell_value(0, col, columnHeaders[col]);
                grid.set_cell_bg_color(0, col, 0x667eeaFF);
                grid.set_cell_fg_color(0, col, 0xFFFFFFFF);
                grid.set_cell_font_style(0, col, true, false);
            }

            // Sample product data
            const sampleData = [
                ["P001", "ãƒãƒ¼ãƒˆãƒ‘ã‚½ã‚³ãƒ³", "Â¥89,800", "15", "PC", "ãƒ¡ãƒ¼ã‚«ãƒ¼A", "2024-01-15", "â˜…â˜…â˜…â˜…â˜†", "1,250", "äººæ°—å•†å“"],
                ["P002", "ãƒ¯ã‚¤ãƒ¤ãƒ¬ã‚¹ãƒã‚¦ã‚¹", "Â¥2,980", "42", "å‘¨è¾ºæ©Ÿå™¨", "ãƒ¡ãƒ¼ã‚«ãƒ¼B", "2024-02-01", "â˜…â˜…â˜…â˜…â˜…", "3,500", "ãƒ™ã‚¹ãƒˆã‚»ãƒ©ãƒ¼"],
                ["P003", "å¤–ä»˜ã‘SSD 1TB", "Â¥12,800", "28", "ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸", "ãƒ¡ãƒ¼ã‚«ãƒ¼C", "2024-01-20", "â˜…â˜…â˜…â˜…â˜†", "890", ""],
                ["P004", "ã‚²ãƒ¼ãƒŸãƒ³ã‚°ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰", "Â¥8,900", "19", "å‘¨è¾ºæ©Ÿå™¨", "ãƒ¡ãƒ¼ã‚«ãƒ¼D", "2023-12-10", "â˜…â˜…â˜…â˜…â˜†", "650", "RGBå¯¾å¿œ"],
                ["P005", "4Kãƒ¢ãƒ‹ã‚¿ãƒ¼ 27å‹", "Â¥35,800", "8", "ãƒ‡ã‚£ã‚¹ãƒ—ãƒ¬ã‚¤", "ãƒ¡ãƒ¼ã‚«ãƒ¼A", "2024-03-01", "â˜…â˜…â˜…â˜…â˜…", "420", "æ–°è£½å“"],
                ["P006", "Webã‚«ãƒ¡ãƒ©", "Â¥5,980", "33", "å‘¨è¾ºæ©Ÿå™¨", "ãƒ¡ãƒ¼ã‚«ãƒ¼E", "2023-11-15", "â˜…â˜…â˜…â˜†â˜†", "1,100", ""],
                ["P007", "USB-Cãƒãƒ–", "Â¥3,480", "55", "å‘¨è¾ºæ©Ÿå™¨", "ãƒ¡ãƒ¼ã‚«ãƒ¼F", "2024-01-05", "â˜…â˜…â˜…â˜…â˜†", "2,200", "ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆ"],
                ["P008", "ãƒ¯ã‚¤ãƒ¤ãƒ¬ã‚¹ã‚¤ãƒ¤ãƒ›ãƒ³", "Â¥9,800", "24", "ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª", "ãƒ¡ãƒ¼ã‚«ãƒ¼G", "2024-02-14", "â˜…â˜…â˜…â˜…â˜…", "1,800", "ãƒã‚¤ã‚­ãƒ£ãƒ³æ­è¼‰"],
                ["P009", "ãƒ‡ã‚¹ã‚¯ãƒ©ã‚¤ãƒˆ", "Â¥4,500", "37", "ç…§æ˜", "ãƒ¡ãƒ¼ã‚«ãƒ¼H", "2023-10-20", "â˜…â˜…â˜…â˜…â˜†", "980", "èª¿å…‰æ©Ÿèƒ½ä»˜"],
                ["P010", "ã‚¨ãƒ«ã‚´ãƒãƒŸãƒƒã‚¯ãƒã‚§ã‚¢", "Â¥28,000", "12", "å®¶å…·", "ãƒ¡ãƒ¼ã‚«ãƒ¼I", "2024-01-30", "â˜…â˜…â˜…â˜…â˜†", "320", "è…°ç—›å¯¾ç­–"],
                ["P011", "ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¿ãƒ–ãƒ¬ãƒƒãƒˆ", "Â¥15,800", "16", "å‘¨è¾ºæ©Ÿå™¨", "ãƒ¡ãƒ¼ã‚«ãƒ¼D", "2023-12-01", "â˜…â˜…â˜…â˜…â˜†", "540", "ãƒ—ãƒ­å‘ã‘"],
                ["P012", "ãƒãƒ¼ã‚¿ãƒ–ãƒ«ãƒãƒƒãƒ†ãƒªãƒ¼", "Â¥7,980", "29", "é›»æº", "ãƒ¡ãƒ¼ã‚«ãƒ¼J", "2024-02-20", "â˜…â˜…â˜…â˜…â˜†", "1,350", "å¤§å®¹é‡"],
                ["P013", "ã‚¹ãƒãƒ¼ãƒˆã‚¦ã‚©ãƒƒãƒ", "Â¥22,800", "18", "ã‚¦ã‚§ã‚¢ãƒ©ãƒ–ãƒ«", "ãƒ¡ãƒ¼ã‚«ãƒ¼K", "2024-03-10", "â˜…â˜…â˜…â˜…â˜…", "780", "å¥åº·ç®¡ç†"],
                ["P014", "ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚¹ã‚­ãƒ£ãƒŠ", "Â¥18,900", "11", "å‘¨è¾ºæ©Ÿå™¨", "ãƒ¡ãƒ¼ã‚«ãƒ¼L", "2023-11-30", "â˜…â˜…â˜…â˜†â˜†", "290", ""],
                ["P015", "ãƒ¡ã‚«ãƒ‹ã‚«ãƒ«ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰", "Â¥12,500", "22", "å‘¨è¾ºæ©Ÿå™¨", "ãƒ¡ãƒ¼ã‚«ãƒ¼D", "2024-01-25", "â˜…â˜…â˜…â˜…â˜†", "710", "é’è»¸"],
                ["P016", "ãƒ¯ã‚¤ãƒ¤ãƒ¬ã‚¹å……é›»å™¨", "Â¥3,280", "46", "é›»æº", "ãƒ¡ãƒ¼ã‚«ãƒ¼M", "2024-02-05", "â˜…â˜…â˜…â˜…â˜†", "1,950", "Qiå¯¾å¿œ"],
                ["P017", "ãƒã‚¤ã‚­ãƒ£ãƒ³ãƒ˜ãƒƒãƒ‰ãƒ›ãƒ³", "Â¥19,800", "14", "ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª", "ãƒ¡ãƒ¼ã‚«ãƒ¼G", "2024-03-05", "â˜…â˜…â˜…â˜…â˜…", "620", "é«˜éŸ³è³ª"],
                ["P018", "PCã‚¹ã‚¿ãƒ³ãƒ‰", "Â¥2,780", "51", "å‘¨è¾ºæ©Ÿå™¨", "ãƒ¡ãƒ¼ã‚«ãƒ¼N", "2023-12-15", "â˜…â˜…â˜…â˜†â˜†", "1,420", "ã‚¢ãƒ«ãƒŸè£½"]
            ];

            for (let row = 0; row < sampleData.length; row++) {
                for (let col = 0; col < sampleData[row].length; col++) {
                    grid.update_cell_value(row + 1, col, sampleData[row][col]);
                }
            }

            updateEditStatus('ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ');
        });

        document.getElementById('undo-btn').addEventListener('click', handleUndo);
        document.getElementById('redo-btn').addEventListener('click', handleRedo);

        document.getElementById('clear-btn').addEventListener('click', () => {
            if (!grid) return;
            if (!confirm('ã™ã¹ã¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) return;

            for (let row = 0; row < 20; row++) {
                for (let col = 0; col < 10; col++) {
                    grid.update_cell_value(row, col, '');
                }
            }

            editCount = 0;
            editHistory = [];
            document.getElementById('edit-count').textContent = '0';
            updateEditHistoryDisplay();
            updateEditStatus('ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
        });

        document.getElementById('readonly-mode').addEventListener('change', (e) => {
            if (e.target.checked) {
                updateEditStatus('èª­å–å°‚ç”¨ãƒ¢ãƒ¼ãƒ‰ãŒæœ‰åŠ¹ã§ã™');
            } else {
                updateEditStatus('ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ãŒæœ‰åŠ¹ã§ã™');
            }
        });

        // Window resize handler
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (!grid) return;

                const width = Math.floor(entry.contentRect.width);
                const height = Math.floor(entry.contentRect.height);

                const webglCanvas = document.getElementById('webgl-canvas');
                const textCanvas = document.getElementById('text-canvas');

                webglCanvas.width = width;
                webglCanvas.height = height;
                textCanvas.width = width;
                textCanvas.height = height;

                grid.resize(width, height);
                updateVirtualScrollSize();
            }
        });

        resizeObserver.observe(document.getElementById('scroll-container'));

        // Initialize
        initGrid();
    </script>
</body>
</html>
