<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataGrid5 - Cell Editing Example</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .header {
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 28px;
            color: #2d3748;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #718096;
            font-size: 14px;
        }

        .controls {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            border-top: 1px solid #e2e8f0;
        }

        button {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        button:hover {
            background: #5a67d8;
        }

        button:active {
            transform: translateY(1px);
        }

        .btn-secondary {
            background: #48bb78;
        }

        .btn-secondary:hover {
            background: #38a169;
        }

        .btn-danger {
            background: #f56565;
        }

        .btn-danger:hover {
            background: #e53e3e;
        }

        .info-section {
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.85);
            border-top: 1px solid #e2e8f0;
        }

        .info-title {
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .info-list {
            list-style: none;
            font-size: 13px;
            color: #4a5568;
            line-height: 1.6;
        }

        .info-list li {
            padding: 3px 0;
        }

        .info-list strong {
            color: #667eea;
        }

        .grid-container {
            flex: 1;
            position: relative;
            min-height: 0;
            background: white;
            margin: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            overflow: hidden;
        }

        #scroll-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
            z-index: 3;
        }

        #scroll-content {
            position: relative;
            pointer-events: none;
        }

        #webgl-canvas, #text-canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            pointer-events: none;
        }

        #webgl-canvas {
            z-index: 1;
        }

        #text-canvas {
            z-index: 2;
            pointer-events: all;
        }

        #text-canvas {
            cursor: cell;
        }

        #cell-editor {
            position: absolute;
            border: 2px solid #667eea;
            outline: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            padding: 4px;
            box-sizing: border-box;
            z-index: 1000;
            background: white;
        }

        .status-bar {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            border-top: 1px solid #e2e8f0;
            display: flex;
            gap: 20px;
            font-size: 13px;
            color: #4a5568;
        }

        .status-item {
            display: flex;
            gap: 5px;
        }

        .status-label {
            font-weight: bold;
            color: #2d3748;
        }

        .edit-history {
            max-height: 100px;
            overflow-y: auto;
            padding: 8px;
            background: #f7fafc;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 5px;
        }

        .edit-entry {
            padding: 2px 0;
            color: #4a5568;
        }

        .controls label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            color: #2d3748;
        }

        .controls input[type="checkbox"] {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>DataGrid5 - セル編集機能デモ</h1>
        <p class="subtitle">Cell Editing Example - Double-click cells to edit</p>
    </div>

    <div class="controls">
        <button id="load-sample-btn" class="btn-secondary">サンプルデータ読込</button>
        <button id="undo-btn">元に戻す (Undo)</button>
        <button id="redo-btn">やり直し (Redo)</button>
        <button id="clear-btn" class="btn-danger">全クリア</button>
        <label>
            <input type="checkbox" id="readonly-mode" />
            読取専用モード
        </label>
    </div>

    <div class="info-section">
        <div class="info-title">📝 編集操作 / Editing Operations:</div>
        <ul class="info-list">
            <li><strong>ダブルクリック:</strong> セルを編集モードにする</li>
            <li><strong>Enter:</strong> 編集を確定して次の行へ</li>
            <li><strong>Tab:</strong> 編集を確定して次の列へ</li>
            <li><strong>Escape:</strong> 編集をキャンセル</li>
            <li><strong>Ctrl+Z / Cmd+Z:</strong> 元に戻す</li>
            <li><strong>Ctrl+Y / Cmd+Y:</strong> やり直し</li>
        </ul>
        <div class="edit-history" id="edit-history">
            <div style="color: #a0aec0;">編集履歴がここに表示されます...</div>
        </div>
    </div>

    <div class="grid-container">
        <canvas id="webgl-canvas"></canvas>
        <canvas id="text-canvas" tabindex="0"></canvas>
        <div id="scroll-container">
            <div id="scroll-content"></div>
        </div>
        <input type="text" id="cell-editor" style="display: none;" />
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span class="status-label">選択:</span>
            <span id="selected-cell">-</span>
        </div>
        <div class="status-item">
            <span class="status-label">編集回数:</span>
            <span id="edit-count">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">状態:</span>
            <span id="edit-status">待機中</span>
        </div>
    </div>

    <script type="module">
        import init, { DataGrid } from '../pkg/datagrid5.js';

        let grid = null;
        let editingRow = null;
        let editingCol = null;
        let editCount = 0;
        let editHistory = [];
        let isInternalScroll = false;

        async function initGrid() {
            await init();

            const webglCanvas = document.getElementById('webgl-canvas');
            const textCanvas = document.getElementById('text-canvas');
            const scrollContainer = document.getElementById('scroll-container');

            // Get container size
            const containerRect = scrollContainer.getBoundingClientRect();
            const width = Math.floor(containerRect.width);
            const height = Math.floor(containerRect.height);

            // Setup canvases
            webglCanvas.width = width;
            webglCanvas.height = height;
            textCanvas.width = width;
            textCanvas.height = height;

            // Create grid (20 rows x 10 columns for editing demo)
            grid = new DataGrid('webgl-canvas', 'text-canvas', 20, 10);

            // Setup event handlers
            setupEventHandlers();
            setupVirtualScroll();

            // Start render loop
            renderLoop();

            console.log('Grid initialized for editing demo');
        }

        function renderLoop() {
            if (!grid) return;
            grid.render();
            requestAnimationFrame(renderLoop);
        }

        function setupEventHandlers() {
            const textCanvas = document.getElementById('text-canvas');

            // Mouse events
            textCanvas.addEventListener('mousedown', (e) => {
                const rect = textCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const modifiers = {
                    shift: e.shiftKey,
                    ctrl: e.ctrlKey || e.metaKey,
                    alt: e.altKey
                };

                grid.handle_mouse_down_with_modifiers(x, y, modifiers);
                updateStatusBar();
            });

            textCanvas.addEventListener('mousemove', (e) => {
                const rect = textCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                grid.handle_mouse_move(x, y);
            });

            textCanvas.addEventListener('mouseup', (e) => {
                const rect = textCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                grid.handle_mouse_up(x, y);
            });

            // Double-click to edit
            textCanvas.addEventListener('dblclick', (e) => {
                const rect = textCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const cellInfo = grid.handle_double_click(x, y);
                if (cellInfo) {
                    const [row, col] = JSON.parse(cellInfo);
                    startCellEdit(row, col);
                }
            });

            // Keyboard events
            textCanvas.addEventListener('keydown', (e) => {
                const modifiers = {
                    shift: e.shiftKey,
                    ctrl: e.ctrlKey || e.metaKey,
                    alt: e.altKey
                };

                // Undo/Redo
                if (modifiers.ctrl) {
                    if (e.key === 'z' || e.key === 'Z') {
                        e.preventDefault();
                        handleUndo();
                        return;
                    }
                    if (e.key === 'y' || e.key === 'Y') {
                        e.preventDefault();
                        handleRedo();
                        return;
                    }
                }

                const handled = grid.handle_keyboard_with_modifiers(e.key, modifiers);
                if (handled) {
                    e.preventDefault();
                    syncScrollPosition();
                    updateStatusBar();
                }
            });

            // Wheel events
            textCanvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                grid.handle_wheel(e.deltaX, e.deltaY);
            });
        }

        function setupVirtualScroll() {
            const scrollContainer = document.getElementById('scroll-container');

            updateVirtualScrollSize();

            scrollContainer.addEventListener('scroll', () => {
                if (!grid || isInternalScroll) {
                    isInternalScroll = false;
                    return;
                }

                const scrollX = scrollContainer.scrollLeft;
                const scrollY = scrollContainer.scrollTop;
                grid.set_scroll(scrollX, scrollY);
            });
        }

        function updateVirtualScrollSize() {
            if (!grid) return;

            const scrollContent = document.getElementById('scroll-content');
            const totalSize = JSON.parse(grid.get_total_size());
            const [totalWidth, totalHeight] = totalSize;

            scrollContent.style.width = totalWidth + 'px';
            scrollContent.style.height = totalHeight + 'px';
        }

        function syncScrollPosition() {
            if (!grid) return;

            const scrollContainer = document.getElementById('scroll-container');
            const viewport = JSON.parse(grid.get_viewport_info_array());
            const [canvasWidth, canvasHeight, scrollY, scrollX] = viewport;

            isInternalScroll = true;
            scrollContainer.scrollLeft = scrollX;
            scrollContainer.scrollTop = scrollY;
        }

        function startCellEdit(row, col) {
            if (!grid) return;

            // Check readonly mode
            const readonlyMode = document.getElementById('readonly-mode').checked;
            if (readonlyMode) {
                updateEditStatus('読取専用モードです');
                return;
            }

            const editor = document.getElementById('cell-editor');
            const scrollContainer = document.getElementById('scroll-container');
            const gridContainer = document.querySelector('.grid-container');

            // Start edit in grid
            const canEdit = grid.start_edit(row, col);
            if (!canEdit) {
                updateEditStatus('このセルは編集できません');
                return;
            }

            // Get cell position
            const rect = grid.get_cell_edit_rect(row, col);
            const [x, y, width, height] = rect;

            // Get current value
            const currentValue = grid.get_cell_value(row, col);

            // Calculate position
            const scrollContainerRect = scrollContainer.getBoundingClientRect();
            const gridContainerRect = gridContainer.getBoundingClientRect();
            const offsetX = scrollContainerRect.left - gridContainerRect.left;
            const offsetY = scrollContainerRect.top - gridContainerRect.top;

            // Position editor
            editor.style.left = `${x + offsetX - scrollContainer.scrollLeft}px`;
            editor.style.top = `${y + offsetY - scrollContainer.scrollTop}px`;
            editor.style.width = `${width}px`;
            editor.style.height = `${height}px`;
            editor.style.display = 'block';
            editor.value = currentValue;

            editingRow = row;
            editingCol = col;

            editor.focus();
            editor.select();

            setupEditorEvents(editor, row, col);
            updateEditStatus('編集中...');
        }

        function endCellEdit(save = false, moveDown = false, moveRight = false) {
            if (!grid || editingRow === null || editingCol === null) return;

            const editor = document.getElementById('cell-editor');
            const oldValue = grid.get_cell_value(editingRow, editingCol);

            if (save && editor.value !== oldValue) {
                // Save value
                grid.update_cell_value(editingRow, editingCol, editor.value);

                // Record edit
                editCount++;
                addEditHistory(editingRow, editingCol, oldValue, editor.value);
                document.getElementById('edit-count').textContent = editCount;
                updateEditStatus('保存しました');
            } else {
                updateEditStatus('キャンセルしました');
            }

            // Hide editor
            editor.style.display = 'none';
            editor.value = '';

            // End edit mode
            grid.end_edit();

            const currentRow = editingRow;
            const currentCol = editingCol;

            editingRow = null;
            editingCol = null;

            // Move to next cell if requested
            if (save && moveDown && currentRow < 19) {
                setTimeout(() => startCellEdit(currentRow + 1, currentCol), 10);
            } else if (save && moveRight && currentCol < 9) {
                setTimeout(() => startCellEdit(currentRow, currentCol + 1), 10);
            } else {
                document.getElementById('text-canvas').focus();
            }
        }

        function setupEditorEvents(editor, row, col) {
            const newEditor = editor.cloneNode(true);
            editor.parentNode.replaceChild(newEditor, editor);

            // Enter to save and move down
            newEditor.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    endCellEdit(true, true, false);
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    endCellEdit(true, false, true);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    endCellEdit(false);
                }
            });

            // Click outside to save
            newEditor.addEventListener('blur', (e) => {
                setTimeout(() => endCellEdit(true), 100);
            });
        }

        function addEditHistory(row, col, oldValue, newValue) {
            const timestamp = new Date().toLocaleTimeString('ja-JP');
            const entry = `[${timestamp}] セル(${row}, ${col}): "${oldValue}" → "${newValue}"`;

            editHistory.unshift(entry);
            if (editHistory.length > 20) {
                editHistory.pop();
            }

            updateEditHistoryDisplay();
        }

        function updateEditHistoryDisplay() {
            const historyDiv = document.getElementById('edit-history');
            if (editHistory.length === 0) {
                historyDiv.innerHTML = '<div style="color: #a0aec0;">編集履歴がここに表示されます...</div>';
            } else {
                historyDiv.innerHTML = editHistory
                    .map(entry => `<div class="edit-entry">${entry}</div>`)
                    .join('');
            }
        }

        function updateStatusBar() {
            if (!grid) return;

            const selectedCell = grid.get_selected_cell();
            if (selectedCell) {
                const [row, col] = JSON.parse(selectedCell);
                const value = grid.get_cell_value(row, col);
                document.getElementById('selected-cell').textContent =
                    `行${row}, 列${col} = "${value}"`;
            } else {
                document.getElementById('selected-cell').textContent = '-';
            }
        }

        function updateEditStatus(message) {
            document.getElementById('edit-status').textContent = message;
            setTimeout(() => {
                if (document.getElementById('edit-status').textContent === message) {
                    document.getElementById('edit-status').textContent = '待機中';
                }
            }, 3000);
        }

        function handleUndo() {
            if (grid) {
                grid.undo();
                updateEditStatus('元に戻しました');
            }
        }

        function handleRedo() {
            if (grid) {
                grid.redo();
                updateEditStatus('やり直しました');
            }
        }

        // Button event handlers
        document.getElementById('load-sample-btn').addEventListener('click', () => {
            if (!grid) return;

            // Set column headers
            const columnHeaders = [
                "商品ID", "商品名", "価格", "在庫数", "カテゴリ",
                "メーカー", "発売日", "評価", "販売数", "備考"
            ];

            for (let col = 0; col < columnHeaders.length; col++) {
                grid.update_cell_value(0, col, columnHeaders[col]);
                grid.set_cell_bg_color(0, col, 0x667eeaFF);
                grid.set_cell_fg_color(0, col, 0xFFFFFFFF);
                grid.set_cell_font_style(0, col, true, false);
            }

            // Sample product data
            const sampleData = [
                ["P001", "ノートパソコン", "¥89,800", "15", "PC", "メーカーA", "2024-01-15", "★★★★☆", "1,250", "人気商品"],
                ["P002", "ワイヤレスマウス", "¥2,980", "42", "周辺機器", "メーカーB", "2024-02-01", "★★★★★", "3,500", "ベストセラー"],
                ["P003", "外付けSSD 1TB", "¥12,800", "28", "ストレージ", "メーカーC", "2024-01-20", "★★★★☆", "890", ""],
                ["P004", "ゲーミングキーボード", "¥8,900", "19", "周辺機器", "メーカーD", "2023-12-10", "★★★★☆", "650", "RGB対応"],
                ["P005", "4Kモニター 27型", "¥35,800", "8", "ディスプレイ", "メーカーA", "2024-03-01", "★★★★★", "420", "新製品"],
                ["P006", "Webカメラ", "¥5,980", "33", "周辺機器", "メーカーE", "2023-11-15", "★★★☆☆", "1,100", ""],
                ["P007", "USB-Cハブ", "¥3,480", "55", "周辺機器", "メーカーF", "2024-01-05", "★★★★☆", "2,200", "コンパクト"],
                ["P008", "ワイヤレスイヤホン", "¥9,800", "24", "オーディオ", "メーカーG", "2024-02-14", "★★★★★", "1,800", "ノイキャン搭載"],
                ["P009", "デスクライト", "¥4,500", "37", "照明", "メーカーH", "2023-10-20", "★★★★☆", "980", "調光機能付"],
                ["P010", "エルゴノミックチェア", "¥28,000", "12", "家具", "メーカーI", "2024-01-30", "★★★★☆", "320", "腰痛対策"],
                ["P011", "グラフィックタブレット", "¥15,800", "16", "周辺機器", "メーカーD", "2023-12-01", "★★★★☆", "540", "プロ向け"],
                ["P012", "ポータブルバッテリー", "¥7,980", "29", "電源", "メーカーJ", "2024-02-20", "★★★★☆", "1,350", "大容量"],
                ["P013", "スマートウォッチ", "¥22,800", "18", "ウェアラブル", "メーカーK", "2024-03-10", "★★★★★", "780", "健康管理"],
                ["P014", "ドキュメントスキャナ", "¥18,900", "11", "周辺機器", "メーカーL", "2023-11-30", "★★★☆☆", "290", ""],
                ["P015", "メカニカルキーボード", "¥12,500", "22", "周辺機器", "メーカーD", "2024-01-25", "★★★★☆", "710", "青軸"],
                ["P016", "ワイヤレス充電器", "¥3,280", "46", "電源", "メーカーM", "2024-02-05", "★★★★☆", "1,950", "Qi対応"],
                ["P017", "ノイキャンヘッドホン", "¥19,800", "14", "オーディオ", "メーカーG", "2024-03-05", "★★★★★", "620", "高音質"],
                ["P018", "PCスタンド", "¥2,780", "51", "周辺機器", "メーカーN", "2023-12-15", "★★★☆☆", "1,420", "アルミ製"]
            ];

            for (let row = 0; row < sampleData.length; row++) {
                for (let col = 0; col < sampleData[row].length; col++) {
                    grid.update_cell_value(row + 1, col, sampleData[row][col]);
                }
            }

            updateEditStatus('サンプルデータを読み込みました');
        });

        document.getElementById('undo-btn').addEventListener('click', handleUndo);
        document.getElementById('redo-btn').addEventListener('click', handleRedo);

        document.getElementById('clear-btn').addEventListener('click', () => {
            if (!grid) return;
            if (!confirm('すべてのデータをクリアしますか？')) return;

            for (let row = 0; row < 20; row++) {
                for (let col = 0; col < 10; col++) {
                    grid.update_cell_value(row, col, '');
                }
            }

            editCount = 0;
            editHistory = [];
            document.getElementById('edit-count').textContent = '0';
            updateEditHistoryDisplay();
            updateEditStatus('データをクリアしました');
        });

        document.getElementById('readonly-mode').addEventListener('change', (e) => {
            if (e.target.checked) {
                updateEditStatus('読取専用モードが有効です');
            } else {
                updateEditStatus('編集モードが有効です');
            }
        });

        // Window resize handler
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (!grid) return;

                const width = Math.floor(entry.contentRect.width);
                const height = Math.floor(entry.contentRect.height);

                const webglCanvas = document.getElementById('webgl-canvas');
                const textCanvas = document.getElementById('text-canvas');

                webglCanvas.width = width;
                webglCanvas.height = height;
                textCanvas.width = width;
                textCanvas.height = height;

                grid.resize(width, height);
                updateVirtualScrollSize();
            }
        });

        resizeObserver.observe(document.getElementById('scroll-container'));

        // Initialize
        initGrid();
    </script>
</body>
</html>
