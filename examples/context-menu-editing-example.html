<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataGrid5 - コンテキストメニュー編集</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .header {
            padding: 25px;
            background: rgba(255, 255, 255, 0.98);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        }

        h1 {
            font-size: 30px;
            color: #1a202c;
            margin-bottom: 8px;
            font-weight: 700;
        }

        .subtitle {
            color: #4a5568;
            font-size: 15px;
            margin-bottom: 8px;
        }

        .description {
            color: #718096;
            font-size: 13px;
            line-height: 1.6;
        }

        .controls {
            padding: 18px 25px;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            border-top: 1px solid #e2e8f0;
        }

        button {
            padding: 10px 18px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 7px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        button:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #48bb78;
        }

        .btn-secondary:hover {
            background: #38a169;
        }

        .info-section {
            padding: 20px 25px;
            background: rgba(255, 255, 255, 0.92);
            border-top: 1px solid #e2e8f0;
        }

        .info-title {
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 12px;
            font-size: 15px;
        }

        .info-list {
            list-style: none;
            font-size: 13px;
            color: #4a5568;
            line-height: 1.8;
        }

        .info-list li::before {
            content: "▸ ";
            color: #667eea;
            font-weight: bold;
            margin-right: 5px;
        }

        .info-list strong {
            color: #2d3748;
        }

        .grid-container {
            flex: 1;
            position: relative;
            min-height: 0;
            background: white;
            margin: 20px 25px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        #scroll-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
            z-index: 3;
        }

        #scroll-content {
            position: relative;
            pointer-events: none;
        }

        #webgl-canvas, #text-canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            pointer-events: none;
        }

        #webgl-canvas {
            z-index: 1;
        }

        #text-canvas {
            z-index: 2;
            pointer-events: all;
        }

        #text-canvas {
            cursor: cell;
        }

        .context-menu {
            position: absolute;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            padding: 6px 0;
            min-width: 200px;
            z-index: 10000;
            display: none;
        }

        .context-menu.show {
            display: block;
        }

        .context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #2d3748;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.15s;
        }

        .context-menu-item:hover {
            background: #edf2f7;
        }

        .context-menu-item.danger {
            color: #e53e3e;
        }

        .context-menu-item.danger:hover {
            background: #fff5f5;
        }

        .context-menu-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .context-menu-item.disabled:hover {
            background: transparent;
        }

        .context-menu-separator {
            height: 1px;
            background: #e2e8f0;
            margin: 6px 0;
        }

        .context-menu-icon {
            width: 16px;
            text-align: center;
        }

        .status-bar {
            padding: 15px 25px;
            background: rgba(255, 255, 255, 0.95);
            border-top: 2px solid #e2e8f0;
            display: flex;
            gap: 30px;
            font-size: 13px;
            color: #4a5568;
        }

        .status-item {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .status-label {
            font-weight: 700;
            color: #2d3748;
        }

        .status-value {
            background: #edf2f7;
            padding: 4px 10px;
            border-radius: 5px;
            font-weight: 600;
            color: #2d3748;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>📋 コンテキストメニューで行を編集</h1>
        <p class="subtitle">Context Menu Row Editing with Undo/Redo</p>
        <p class="description">
            グリッド内で右クリックすると、行の追加・削除ができるコンテキストメニューが表示されます。
            範囲選択している場合は、複数行をまとめて削除できます。すべての操作はUndo/Redoに対応しています。
        </p>
    </div>

    <div class="controls">
        <button id="load-data-btn" class="btn-secondary">📋 サンプルデータ読込</button>
        <button id="undo-btn">↶ 元に戻す (Ctrl+Z)</button>
        <button id="redo-btn">↷ やり直し (Ctrl+Y)</button>
    </div>

    <div class="info-section">
        <div class="info-title">💡 操作方法</div>
        <ul class="info-list">
            <li><strong>右クリック:</strong> コンテキストメニューを表示</li>
            <li><strong>現在の行の下に追加:</strong> アクティブセルの下に新しい行を挿入</li>
            <li><strong>現在の行を削除:</strong> アクティブセルの行を削除</li>
            <li><strong>選択範囲の行を削除:</strong> 選択中のすべての行をまとめて削除</li>
            <li><strong>Ctrl+Z / Cmd+Z:</strong> 操作を元に戻す</li>
            <li><strong>Ctrl+Y / Cmd+Y:</strong> 操作をやり直す</li>
            <li><strong>範囲選択:</strong> Shiftキーを押しながらクリック、またはマウスドラッグ</li>
        </ul>
    </div>

    <div class="grid-container">
        <canvas id="webgl-canvas"></canvas>
        <canvas id="text-canvas" tabindex="0"></canvas>
        <div id="scroll-container">
            <div id="scroll-content"></div>
        </div>
        <div class="context-menu" id="context-menu">
            <div class="context-menu-item" id="menu-insert-row">
                <span class="context-menu-icon">➕</span>
                <span>現在の行の下に追加</span>
            </div>
            <div class="context-menu-separator"></div>
            <div class="context-menu-item danger" id="menu-delete-row">
                <span class="context-menu-icon">🗑️</span>
                <span>現在の行を削除</span>
            </div>
            <div class="context-menu-item danger" id="menu-delete-selected-rows">
                <span class="context-menu-icon">🗑️</span>
                <span>選択範囲の行を削除 (<span id="selected-row-count">0</span>行)</span>
            </div>
            <div class="context-menu-separator"></div>
            <div class="context-menu-item" id="menu-undo">
                <span class="context-menu-icon">↶</span>
                <span>元に戻す</span>
            </div>
            <div class="context-menu-item" id="menu-redo">
                <span class="context-menu-icon">↷</span>
                <span>やり直し</span>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span class="status-label">総行数:</span>
            <span class="status-value" id="total-rows">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">選択セル数:</span>
            <span class="status-value" id="selected-cells">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">選択行数:</span>
            <span class="status-value" id="selected-rows-status">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">操作回数:</span>
            <span class="status-value" id="operation-count">0</span>
        </div>
    </div>

    <script type="module">
        import init, { DataGrid } from '../pkg/datagrid5.js';

        let grid = null;
        let isInternalScroll = false;
        let operationCount = 0;
        let contextMenuRow = null;
        let contextMenuCol = null;

        async function initGrid() {
            await init();

            const webglCanvas = document.getElementById('webgl-canvas');
            const textCanvas = document.getElementById('text-canvas');
            const scrollContainer = document.getElementById('scroll-container');

            const containerRect = scrollContainer.getBoundingClientRect();
            const width = Math.floor(containerRect.width);
            const height = Math.floor(containerRect.height);

            webglCanvas.width = width;
            webglCanvas.height = height;
            textCanvas.width = width;
            textCanvas.height = height;

            // Create grid: 15 rows × 6 columns
            grid = new DataGrid('webgl-canvas', 'text-canvas', 15, 6);

            setupEventHandlers();
            setupVirtualScroll();

            // Start render loop
            renderLoop();

            console.log('Context menu editing grid initialized');
            updateStatus();
        }

        function renderLoop() {
            if (!grid) return;
            grid.render();
            requestAnimationFrame(renderLoop);
        }

        function setupEventHandlers() {
            const textCanvas = document.getElementById('text-canvas');

            textCanvas.addEventListener('mousedown', (e) => {
                const rect = textCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                grid.handle_mouse_down_with_modifiers(x, y, {
                    shift: e.shiftKey,
                    ctrl: e.ctrlKey || e.metaKey,
                    alt: e.altKey
                });
                updateStatus();
            });

            textCanvas.addEventListener('mousemove', (e) => {
                const rect = textCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                grid.handle_mouse_move(x, y);
            });

            textCanvas.addEventListener('mouseup', (e) => {
                const rect = textCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                grid.handle_mouse_up(x, y);
                updateStatus();
            });

            textCanvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showContextMenu(e.clientX, e.clientY, e);
            });

            textCanvas.addEventListener('keydown', (e) => {
                const modifiers = {
                    shift: e.shiftKey,
                    ctrl: e.ctrlKey || e.metaKey,
                    alt: e.altKey
                };

                // Handle Ctrl+Z / Cmd+Z for undo
                if (modifiers.ctrl && e.key === 'z') {
                    e.preventDefault();
                    handleUndo();
                    return;
                }

                // Handle Ctrl+Y / Cmd+Y for redo
                if (modifiers.ctrl && e.key === 'y') {
                    e.preventDefault();
                    handleRedo();
                    return;
                }

                const handled = grid.handle_keyboard_with_modifiers(e.key, modifiers);
                if (handled) {
                    e.preventDefault();
                    syncScrollPosition();
                }
            });

            textCanvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                grid.handle_wheel(e.deltaX, e.deltaY);
            });

            // Hide context menu when clicking elsewhere
            document.addEventListener('click', hideContextMenu);
        }

        function setupVirtualScroll() {
            const scrollContainer = document.getElementById('scroll-container');
            updateVirtualScrollSize();

            scrollContainer.addEventListener('scroll', () => {
                if (!grid || isInternalScroll) {
                    isInternalScroll = false;
                    return;
                }
                grid.set_scroll(scrollContainer.scrollLeft, scrollContainer.scrollTop);
            });
        }

        function updateVirtualScrollSize() {
            if (!grid) return;
            const scrollContent = document.getElementById('scroll-content');
            const totalSize = JSON.parse(grid.get_total_size());
            scrollContent.style.width = totalSize[0] + 'px';
            scrollContent.style.height = totalSize[1] + 'px';
        }

        function syncScrollPosition() {
            if (!grid) return;
            const scrollContainer = document.getElementById('scroll-container');
            const viewport = JSON.parse(grid.get_viewport_info_array());
            isInternalScroll = true;
            scrollContainer.scrollLeft = viewport[3];
            scrollContainer.scrollTop = viewport[2];
        }

        function showContextMenu(x, y, event) {
            if (!grid) return;

            const textCanvas = document.getElementById('text-canvas');
            const rect = textCanvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;

            // Get cell at click position (approximate)
            const selectedCell = grid.get_selected_cell();
            if (selectedCell) {
                [contextMenuRow, contextMenuCol] = JSON.parse(selectedCell);
            }

            const menu = document.getElementById('context-menu');
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.add('show');

            // Update menu items based on selection
            const selectedRowsJson = grid.get_selected_row_indices();
            const selectedRows = JSON.parse(selectedRowsJson);
            const selectedRowCount = selectedRows.length;

            document.getElementById('selected-row-count').textContent = selectedRowCount;

            const deleteSelectedItem = document.getElementById('menu-delete-selected-rows');
            if (selectedRowCount > 1) {
                deleteSelectedItem.classList.remove('disabled');
            } else {
                deleteSelectedItem.classList.add('disabled');
            }

            updateStatus();
        }

        function hideContextMenu() {
            const menu = document.getElementById('context-menu');
            menu.classList.remove('show');
        }

        function handleInsertRow() {
            if (!grid || contextMenuRow === null) return;

            const insertIndex = contextMenuRow + 1;
            grid.insert_row(insertIndex);

            operationCount++;
            updateStatus();
            updateVirtualScrollSize();
            hideContextMenu();
        }

        function handleDeleteRow() {
            if (!grid || contextMenuRow === null) return;

            grid.delete_row(contextMenuRow);

            operationCount++;
            updateStatus();
            updateVirtualScrollSize();
            hideContextMenu();
        }

        function handleDeleteSelectedRows() {
            if (!grid) return;

            const selectedRowsJson = grid.get_selected_row_indices();
            const selectedRows = JSON.parse(selectedRowsJson);

            if (selectedRows.length <= 1) return;

            grid.delete_rows(selectedRowsJson);

            operationCount++;
            updateStatus();
            updateVirtualScrollSize();
            hideContextMenu();
        }

        function handleUndo() {
            if (!grid) return;

            const success = grid.undo();
            if (success) {
                operationCount++;
                updateStatus();
                updateVirtualScrollSize();
            }
        }

        function handleRedo() {
            if (!grid) return;

            const success = grid.redo();
            if (success) {
                operationCount++;
                updateStatus();
                updateVirtualScrollSize();
            }
        }

        function updateStatus() {
            if (!grid) return;

            // Total rows
            const totalSize = JSON.parse(grid.get_total_size());
            const rowCount = Math.floor(totalSize[1] / 25); // Approximate
            document.getElementById('total-rows').textContent = rowCount;

            // Selected cells
            const selectionCount = grid.get_selection_count();
            document.getElementById('selected-cells').textContent = selectionCount;

            // Selected rows
            const selectedRowsJson = grid.get_selected_row_indices();
            const selectedRows = JSON.parse(selectedRowsJson);
            document.getElementById('selected-rows-status').textContent = selectedRows.length;

            // Operation count
            document.getElementById('operation-count').textContent = operationCount;
        }

        function loadSampleData() {
            if (!grid) return;

            const headers = ['ID', '商品名', 'カテゴリ', '価格', '在庫', 'ステータス'];
            headers.forEach((header, col) => {
                grid.update_cell_value(0, col, header);
                grid.set_cell_bg_color(0, col, 0x4facfeFF);
                grid.set_cell_fg_color(0, col, 0xFFFFFFFF);
                grid.set_cell_font_style(0, col, true, false);
            });

            const sampleData = [
                ['P001', 'ノートPC', 'PC', '¥89,800', '12', '在庫あり'],
                ['P002', 'マウス', '周辺機器', '¥2,980', '45', '在庫あり'],
                ['P003', 'キーボード', '周辺機器', '¥8,900', '8', '在庫少'],
                ['P004', 'モニター', 'ディスプレイ', '¥35,800', '5', '在庫少'],
                ['P005', 'SSD', 'ストレージ', '¥12,800', '28', '在庫あり'],
                ['P006', 'Webカメラ', '周辺機器', '¥5,980', '33', '在庫あり'],
                ['P007', 'USBハブ', '周辺機器', '¥3,480', '55', '在庫あり'],
                ['P008', 'イヤホン', 'オーディオ', '¥9,800', '24', '在庫あり'],
                ['P009', 'デスクライト', '照明', '¥4,500', '0', '欠品'],
                ['P010', 'チェア', '家具', '¥28,000', '12', '在庫あり'],
                ['P011', 'タブレット', 'PC', '¥15,800', '16', '在庫あり'],
                ['P012', 'バッテリー', '電源', '¥7,980', '29', '在庫あり'],
                ['P013', 'スマートウォッチ', 'ウェアラブル', '¥22,800', '18', '在庫あり'],
                ['P014', 'スキャナ', '周辺機器', '¥18,900', '11', '在庫あり']
            ];

            sampleData.forEach((row, rowIdx) => {
                row.forEach((value, colIdx) => {
                    grid.update_cell_value(rowIdx + 1, colIdx, value);
                });
            });

            updateVirtualScrollSize();
            updateStatus();
        }

        // Context menu item handlers
        document.getElementById('menu-insert-row').addEventListener('click', (e) => {
            e.stopPropagation();
            handleInsertRow();
        });

        document.getElementById('menu-delete-row').addEventListener('click', (e) => {
            e.stopPropagation();
            handleDeleteRow();
        });

        document.getElementById('menu-delete-selected-rows').addEventListener('click', (e) => {
            e.stopPropagation();
            handleDeleteSelectedRows();
        });

        document.getElementById('menu-undo').addEventListener('click', (e) => {
            e.stopPropagation();
            handleUndo();
        });

        document.getElementById('menu-redo').addEventListener('click', (e) => {
            e.stopPropagation();
            handleRedo();
        });

        // Button handlers
        document.getElementById('load-data-btn').addEventListener('click', loadSampleData);
        document.getElementById('undo-btn').addEventListener('click', handleUndo);
        document.getElementById('redo-btn').addEventListener('click', handleRedo);

        // Resize handler
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (!grid) return;

                const width = Math.floor(entry.contentRect.width);
                const height = Math.floor(entry.contentRect.height);

                const webglCanvas = document.getElementById('webgl-canvas');
                const textCanvas = document.getElementById('text-canvas');

                webglCanvas.width = width;
                webglCanvas.height = height;
                textCanvas.width = width;
                textCanvas.height = height;

                grid.resize(width, height);
                updateVirtualScrollSize();
            }
        });

        resizeObserver.observe(document.getElementById('scroll-container'));

        // Initialize
        initGrid();
    </script>
</body>
</html>
