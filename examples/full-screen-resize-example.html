<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataGrid5 - Full Screen Resize Example</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(255, 255, 255, 0.98);
            padding: 15px 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            flex-shrink: 0;
            z-index: 100;
        }

        .header h1 {
            color: #667eea;
            font-size: 1.5em;
            margin-bottom: 8px;
        }

        .header p {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .control-group label {
            font-weight: 600;
            font-size: 0.85em;
            color: #666;
        }

        .control-group input {
            padding: 5px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.85em;
            width: 70px;
        }

        button {
            padding: 6px 14px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85em;
        }

        button:hover {
            background: #5568d3;
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.4);
        }

        .info-bar {
            padding: 8px 20px;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            font-size: 0.8em;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-shrink: 0;
        }

        .info-item {
            display: flex;
            gap: 5px;
        }

        .info-item strong {
            font-weight: 700;
        }

        /* Grid wrapper - fills remaining space */
        .grid-wrapper {
            flex: 1;
            padding: 15px;
            display: flex;
            min-height: 0;
        }

        /* Grid placeholder - fills wrapper */
        #grid-placeholder {
            flex: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            min-height: 0;
            min-width: 0;
            position: relative;
            overflow: hidden;
        }

        /* Virtual scroll container with native scrollbars */
        #scroll-container {
            flex: 1;
            overflow: auto;
            position: relative;
            background: white;
            min-height: 0;
        }

        /* Virtual content area (defines scrollable size) */
        #scroll-content {
            position: relative;
            pointer-events: none;
        }

        /* Stack canvases */
        #webgl-canvas,
        #text-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #webgl-canvas {
            z-index: 1;
        }

        #text-canvas {
            z-index: 2;
            cursor: cell;
            pointer-events: all;
        }

        #text-canvas:focus {
            outline: 3px solid #667eea;
            outline-offset: -3px;
        }

        /* Cell editor */
        #cell-editor {
            position: absolute;
            z-index: 10;
            border: 2px solid #667eea;
            padding: 4px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            box-sizing: border-box;
            background: white;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        #cell-editor:focus {
            outline: none;
            border-color: #5568d3;
        }

        .resize-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 600;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .resize-indicator.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>DataGrid5 - Full Screen Resize Example</h1>
        <p>グリッドがブラウザウィンドウ全体に追従します。ブラウザをリサイズまたは最大化してください。</p>

        <div class="controls">
            <div class="control-group">
                <label>Rows:</label>
                <input type="number" id="rows" value="1000" min="1" max="100000">
            </div>
            <div class="control-group">
                <label>Columns:</label>
                <input type="number" id="cols" value="50" min="1" max="1000">
            </div>
            <button id="recreate-btn">Recreate Grid</button>
            <button id="fill-data-btn">Fill Sample Data</button>
            <button id="toggle-fullscreen-btn">Toggle Fullscreen</button>
        </div>
    </div>

    <div class="info-bar">
        <div class="info-item">
            <strong>Grid:</strong>
            <span id="grid-size">-</span>
        </div>
        <div class="info-item">
            <strong>Canvas:</strong>
            <span id="canvas-size">-</span>
        </div>
        <div class="info-item">
            <strong>Selection:</strong>
            <span id="selection-info">-</span>
        </div>
        <div class="info-item">
            <strong>Browser:</strong>
            <span id="browser-size">-</span>
        </div>
    </div>

    <div class="grid-wrapper">
        <div id="grid-placeholder">
            <canvas id="webgl-canvas"></canvas>
        <canvas id="text-canvas" tabindex="0"></canvas>
        <div id="scroll-container">
            <div id="scroll-content"></div>
        </div>
            <input type="text" id="cell-editor" style="display: none;" />
            <div id="resize-indicator" class="resize-indicator"></div>
        </div>
    </div>

    <script type="module">
        import init, { DataGrid } from '../pkg/datagrid5.js';

        let grid = null;
        let animationFrameId = null;
        let isInternalScroll = false;
        let resizeTimeout = null;

        async function initGrid() {
            await init();

            const rows = parseInt(document.getElementById('rows').value);
            const cols = parseInt(document.getElementById('cols').value);

            try {
                // Stop existing animation loop
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }

                // Get container dimensions
                const container = document.getElementById('scroll-container');
                const width = container.clientWidth;
                const height = container.clientHeight;

                console.log(`Initializing grid: ${width}px × ${height}px`);

                // Create new grid with two canvas layers
                const webglCanvas = document.getElementById('webgl-canvas');
                const textCanvas = document.getElementById('text-canvas');

                webglCanvas.width = width;
                webglCanvas.height = height;
                textCanvas.width = width;
                textCanvas.height = height;

                grid = new DataGrid('webgl-canvas', 'text-canvas', rows, cols);

                // Setup virtual scroll
                setupVirtualScroll();

                // Setup resize observer
                setupResizeObserver();

                // Setup event handlers
                setupEventHandlers();

                // Update info
                updateInfo();

                // Start render loop
                renderLoop();

                console.log('DataGrid initialized successfully');
            } catch (error) {
                console.error('Failed to initialize DataGrid:', error);
                alert('Failed to initialize DataGrid: ' + error);
            }
        }

        function renderLoop() {
            if (!grid) return;
            grid.render();
            animationFrameId = requestAnimationFrame(renderLoop);
        }

        function updateInfo() {
            if (!grid) return;

            const dimensions = grid.get_dimensions();
            const selectionCount = grid.get_selection_count();

            document.getElementById('grid-size').textContent =
                `${dimensions[0]} rows × ${dimensions[1]} cols`;

            const container = document.getElementById('scroll-container');
            document.getElementById('canvas-size').textContent =
                `${container.clientWidth}px × ${container.clientHeight}px`;

            document.getElementById('selection-info').textContent =
                selectionCount > 0 ? `${selectionCount} cells` : 'None';

            document.getElementById('browser-size').textContent =
                `${window.innerWidth}px × ${window.innerHeight}px`;
        }

        // Setup virtual scroll container
        function setupVirtualScroll() {
            if (!grid) return;

            const scrollContainer = document.getElementById('scroll-container');

            // Update virtual content size
            updateVirtualScrollSize();

            // Handle scroll events
            let scrollTimeout = null;
            scrollContainer.addEventListener('scroll', (e) => {
                if (!grid) return;

                // Skip if this is a programmatic scroll from keyboard navigation
                if (isInternalScroll) {
                    isInternalScroll = false;
                    return;
                }

                // Get scroll position from container
                const scrollX = scrollContainer.scrollLeft;
                const scrollY = scrollContainer.scrollTop;

                // Update grid scroll position
                grid.set_scroll(scrollX, scrollY);

                // Debounce render for smoother scrolling
                if (scrollTimeout) {
                    clearTimeout(scrollTimeout);
                }
                scrollTimeout = setTimeout(() => {
                    updateInfo();
                }, 100);
            });

            console.log('Virtual scroll setup complete');
        }

        // Update virtual scroll content size
        function updateVirtualScrollSize() {
            if (!grid) return;

            const scrollContent = document.getElementById('scroll-content');

            // Get total content size from grid
            const totalSize = JSON.parse(grid.get_total_size());
            const [totalWidth, totalHeight] = totalSize;

            // Set virtual content size
            scrollContent.style.width = totalWidth + 'px';
            scrollContent.style.height = totalHeight + 'px';

            console.log(`Virtual scroll size: ${totalWidth} x ${totalHeight}`);
        }

        // Sync scroll container position with grid internal scroll
        function syncScrollPosition() {
            if (!grid) return;

            const scrollContainer = document.getElementById('scroll-container');

            // Get current scroll position from grid
            const viewport = JSON.parse(grid.get_viewport_info_array());
            const [canvasWidth, canvasHeight, scrollY, scrollX] = viewport;

            // Set flag to prevent scroll event loop
            isInternalScroll = true;

            // Update scroll container to match grid's internal scroll
            scrollContainer.scrollLeft = scrollX;
            scrollContainer.scrollTop = scrollY;
        }

        // Setup ResizeObserver for automatic grid resizing
        function setupResizeObserver() {
            const container = document.getElementById('scroll-container');

            const resizeObserver = new ResizeObserver(entries => {
                if (!grid) return;

                for (let entry of entries) {
                    const { width, height } = entry.contentRect;

                    console.log(`Container resized: ${Math.round(width)}px × ${Math.round(height)}px`);

                    // Show resize indicator
                    showResizeIndicator(width, height);

                    // Update canvas dimensions
                    const webglCanvas = document.getElementById('webgl-canvas');
                    const textCanvas = document.getElementById('text-canvas');

                    webglCanvas.width = width;
                    webglCanvas.height = height;
                    textCanvas.width = width;
                    textCanvas.height = height;

                    // Resize grid
                    grid.resize(width, height);

                    // Update virtual scroll size
                    updateVirtualScrollSize();

                    // Update info display
                    updateInfo();
                }
            });

            resizeObserver.observe(container);
            console.log('ResizeObserver setup complete - watching for browser resize');
        }

        // Show resize indicator temporarily
        function showResizeIndicator(width, height) {
            const indicator = document.getElementById('resize-indicator');
            indicator.textContent = `${Math.round(width)} × ${Math.round(height)}`;
            indicator.classList.add('show');

            // Clear existing timeout
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }

            // Hide after 1 second
            resizeTimeout = setTimeout(() => {
                indicator.classList.remove('show');
            }, 1000);
        }

        // Setup event handlers
        function setupEventHandlers() {
            const canvas = document.getElementById('text-canvas');
            let isResizingLocal = false;

            // Mouse events
            canvas.addEventListener('mousedown', (e) => {
                if (!grid) return;

                const x = e.offsetX;
                const y = e.offsetY;

                // Check if clicking on resize handle
                const resizeType = grid.check_resize_handle(x, y);
                if (resizeType !== 'none') {
                    isResizingLocal = true;
                    grid.start_resize(x, y, resizeType);
                    e.preventDefault();
                } else {
                    const shift = e.shiftKey;
                    const ctrl = e.ctrlKey || e.metaKey;
                    grid.handle_mouse_down_with_modifiers(e, shift, ctrl);
                }
                updateInfo();
            });

            canvas.addEventListener('mouseup', (e) => {
                if (!grid) return;

                if (isResizingLocal) {
                    grid.end_resize();
                    isResizingLocal = false;
                    updateVirtualScrollSize();
                } else {
                    grid.handle_mouse_up(e);
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!grid) return;

                const x = e.offsetX;
                const y = e.offsetY;

                if (isResizingLocal) {
                    grid.update_resize(x, y);
                } else {
                    const resizeType = grid.check_resize_handle(x, y);
                    if (resizeType === 'col') {
                        canvas.style.cursor = 'col-resize';
                    } else if (resizeType === 'row') {
                        canvas.style.cursor = 'row-resize';
                    } else {
                        canvas.style.cursor = 'cell';
                    }

                    grid.handle_mouse_move(e);
                }
            });

            canvas.addEventListener('mouseleave', (e) => {
                if (!grid) return;

                if (isResizingLocal) {
                    grid.end_resize();
                    isResizingLocal = false;
                }
                grid.handle_mouse_up(e);
                canvas.style.cursor = 'cell';
            });

            // Keyboard events
            window.addEventListener('keydown', async (e) => {
                if (!grid) return;

                // Copy
                if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
                    e.preventDefault();
                    const tsvData = grid.copy_selected_cells();
                    if (tsvData) {
                        try {
                            await navigator.clipboard.writeText(tsvData);
                            console.log('Copied to clipboard');
                        } catch (err) {
                            console.error('Failed to copy:', err);
                        }
                    }
                    return;
                }

                // Paste
                if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
                    e.preventDefault();
                    try {
                        const text = await navigator.clipboard.readText();
                        if (text) {
                            grid.paste_cells(text);
                            updateInfo();
                        }
                    } catch (err) {
                        console.error('Failed to paste:', err);
                    }
                    return;
                }

                // Select all
                if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
                    e.preventDefault();
                    grid.select_all();
                    updateInfo();
                    return;
                }

                // Keyboard navigation
                const ctrl = e.ctrlKey || e.metaKey;
                const handled = grid.handle_keyboard_with_modifiers(e, ctrl);
                if (handled) {
                    e.preventDefault();
                    syncScrollPosition();
                    updateInfo();
                }
            });

            // Focus canvas on click
            canvas.addEventListener('click', () => {
                canvas.focus();
            });

            // Double-click to edit
            canvas.addEventListener('dblclick', (e) => {
                if (grid && !grid.is_editing()) {
                    const cellPos = grid.handle_double_click(e);
                    if (cellPos) {
                        startCellEdit(cellPos[0], cellPos[1]);
                    }
                }
            });

            // Recreate button
            document.getElementById('recreate-btn').addEventListener('click', () => {
                initGrid();
            });

            // Fill data button
            document.getElementById('fill-data-btn').addEventListener('click', () => {
                if (!grid) return;

                // Define column headers
                const columnHeaders = [
                    "ID", "Employee Name", "Email Address", "Age", "Department",
                    "City", "Country", "Salary", "Start Date", "Status",
                    "Phone", "Manager", "Team", "Active Projects", "Performance Rating"
                ];

                // Set column headers with styling
                for (let col = 0; col < columnHeaders.length; col++) {
                    grid.update_cell_value(0, col, columnHeaders[col]);

                    // Style header row
                    grid.set_cell_bg_color(0, col, 0x667eeaFF); // Purple-blue background
                    grid.set_cell_fg_color(0, col, 0xFFFFFFFF); // White text
                    grid.set_cell_font_style(0, col, true, false); // Bold
                }

                // Fill sample data
                const names = ["Alice Johnson", "Bob Smith", "Charlie Brown", "Diana Prince", "Emma Watson"];
                const departments = ["Engineering", "Sales", "Marketing", "HR", "Finance"];
                const cities = ["Tokyo", "New York", "London", "Paris", "Sydney"];
                const countries = ["Japan", "USA", "UK", "France", "Australia"];
                const statuses = ["Active", "On Leave", "Remote", "In Office"];

                for (let row = 1; row <= 25; row++) {
                    const nameIdx = (row - 1) % names.length;
                    const name = names[nameIdx];

                    grid.update_cell_value(row, 0, String(1000 + row));
                    grid.update_cell_value(row, 1, name);
                    grid.update_cell_value(row, 2, `${name.toLowerCase().replace(' ', '.')}@company.com`);
                    grid.update_cell_value(row, 3, String(25 + (row % 35)));
                    grid.update_cell_value(row, 4, departments[row % departments.length]);
                    grid.update_cell_value(row, 5, cities[row % cities.length]);
                    grid.update_cell_value(row, 6, countries[row % countries.length]);
                    grid.update_cell_value(row, 7, `$${45000 + row * 1500}`);
                    grid.update_cell_value(row, 8, `202${row % 4}-0${1 + (row % 9)}-15`);
                    grid.update_cell_value(row, 9, statuses[row % statuses.length]);
                    grid.update_cell_value(row, 10, `+1-555-${1000 + row}`);
                    grid.update_cell_value(row, 11, names[(nameIdx + 1) % names.length]);
                    grid.update_cell_value(row, 12, `Team ${(row % 5) + 1}`);
                    grid.update_cell_value(row, 13, String(row % 10));
                    grid.update_cell_value(row, 14, `${3.5 + (row % 15) / 10}`);
                }

                console.log('Filled sample data with custom column headers');
            });

            // Fullscreen toggle
            document.getElementById('toggle-fullscreen-btn').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            });
        }

        // Cell editing
        let editingRow = null;
        let editingCol = null;

        function startCellEdit(row, col) {
            if (!grid) return;

            const editor = document.getElementById('cell-editor');
            const scrollContainer = document.getElementById('scroll-container');
            const gridPlaceholder = document.getElementById('grid-placeholder');

            const rect = grid.get_cell_edit_rect(row, col);
            const [x, y, width, height] = rect;

            const currentValue = grid.get_cell_value(row, col);

            const scrollContainerRect = scrollContainer.getBoundingClientRect();
            const gridPlaceholderRect = gridPlaceholder.getBoundingClientRect();
            const offsetX = scrollContainerRect.left - gridPlaceholderRect.left;
            const offsetY = scrollContainerRect.top - gridPlaceholderRect.top;

            editor.style.left = `${x + offsetX - scrollContainer.scrollLeft}px`;
            editor.style.top = `${y + offsetY - scrollContainer.scrollTop}px`;
            editor.style.width = `${width}px`;
            editor.style.height = `${height}px`;
            editor.style.display = 'block';
            editor.value = currentValue;

            editingRow = row;
            editingCol = col;

            editor.focus();
            editor.select();

            setupEditorEvents(editor);
        }

        function endCellEdit(save = false) {
            if (!grid || editingRow === null || editingCol === null) return;

            const editor = document.getElementById('cell-editor');

            if (save) {
                grid.update_cell_value(editingRow, editingCol, editor.value);
            }

            editor.style.display = 'none';
            editor.value = '';

            grid.end_edit();

            editingRow = null;
            editingCol = null;

            document.getElementById('text-canvas').focus();
        }

        function setupEditorEvents(editor) {
            const newEditor = editor.cloneNode(true);
            editor.parentNode.replaceChild(newEditor, editor);

            newEditor.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    endCellEdit(true);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    endCellEdit(false);
                }
            });

            newEditor.addEventListener('blur', () => {
                setTimeout(() => {
                    if (grid && grid.is_editing()) {
                        endCellEdit(true);
                    }
                }, 100);
            });
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initGrid();
        });
    </script>
</body>
</html>
